import { CrankEventTarget } from "./events";
import { MaybePromise, MaybePromiseLike } from "./utils";
export { EventMap } from "./events";
declare global {
    module JSX {
        interface IntrinsicElements {
            [tag: string]: any;
        }
        interface ElementChildrenAttribute {
            children: {};
        }
    }
}
export declare type Tag<TProps = any> = Component<TProps> | string | symbol;
declare type TagProps<TTag extends Tag> = TTag extends Component<infer TProps> ? TProps : TTag extends string ? JSX.IntrinsicElements[TTag] : unknown;
export declare type Key = unknown;
export declare type Child = Element | string | number | boolean | null | undefined;
interface ChildIterable extends Iterable<Child | ChildIterable> {
}
export declare type Children = Child | ChildIterable;
export interface Props {
    "crank-key"?: Key;
    children?: Children;
}
export interface IntrinsicProps<T> {
    children: Array<T | string>;
    [name: string]: any;
}
declare const ElementSigil: unique symbol;
export interface Element<TTag extends Tag = Tag> {
    __sigil__: typeof ElementSigil;
    readonly tag: TTag;
    readonly key: unknown;
    props: TagProps<TTag>;
}
export declare type FunctionComponent<TProps = any> = (this: Context<TProps>, props: TProps) => MaybePromiseLike<Child>;
export declare type ChildIterator<TNext = any> = Iterator<Child, Child, TNext> | AsyncIterator<Child, Child, TNext>;
export declare type ChildGenerator<TNext = any> = Generator<Child, Child, TNext> | AsyncGenerator<Child, Child, TNext>;
export declare type GeneratorComponent<TProps = any> = (this: Context<TProps>, props: TProps) => ChildIterator;
export declare type Component<TProps = any> = (this: Context<TProps>, props: TProps) => ChildIterator | MaybePromiseLike<Child>;
export declare type Intrinsic<T> = (this: HostNode<T>, props: IntrinsicProps<T>) => Iterator<T> | T;
export declare const Fragment: any;
export declare type Fragment = typeof Fragment;
export declare const Copy: any;
export declare type Copy = typeof Copy;
export declare const Portal: any;
export declare type Portal = typeof Portal;
export declare const Raw: any;
export declare type Raw = typeof Raw;
export declare function isElement(value: any): value is Element;
export declare function createElement<TTag extends Tag>(tag: TTag, props?: TagProps<TTag> | null, ...children: Array<unknown>): Element<TTag>;
declare type Node<T> = LeafNode<T> | ParentNode<T>;
interface NodeBase<T> {
    dirty: boolean;
    readonly internal: boolean;
    readonly tag: Tag | undefined;
    readonly key: Key;
    value: Array<T | string> | T | string | undefined;
    previousSibling: Node<T> | undefined;
    nextSibling: Node<T> | undefined;
    alternate: Node<T> | undefined;
}
declare class LeafNode<T> implements NodeBase<T> {
    dirty: boolean;
    readonly internal = false;
    readonly tag: undefined;
    readonly key: undefined;
    value: string | undefined;
    previousSibling: Node<T> | undefined;
    nextSibling: Node<T> | undefined;
    alternate: undefined;
}
declare abstract class ParentNode<T> implements NodeBase<T> {
    dirty: boolean;
    moved: boolean;
    copied: boolean;
    protected updating: boolean;
    protected unmounted: boolean;
    readonly internal = true;
    abstract readonly tag: Tag;
    readonly key: Key;
    value: Array<T | string> | T | string | undefined;
    dirtyStart: number | undefined;
    private keyedChildren;
    private firstChild;
    private lastChild;
    previousSibling: Node<T> | undefined;
    nextSibling: Node<T> | undefined;
    alternate: Node<T> | undefined;
    abstract readonly renderer: Renderer<T>;
    abstract parent: ParentNode<T> | undefined;
    private onNewResult;
    protected props: any;
    ctx: Context | undefined;
    scope: unknown;
    childScope: unknown;
    private appendChild;
    private insertBefore;
    private removeChild;
    private replaceChild;
    update(props: any): MaybePromise<undefined>;
    protected updateChildren(children: Children): MaybePromise<undefined>;
    abstract commit(requester?: ParentNode<T>): MaybePromise<undefined>;
    protected commitChildren(requester?: ParentNode<T>): Array<T | string>;
    abstract unmount(dirty?: boolean): MaybePromise<undefined>;
    protected unmountChildren(dirty: boolean): void;
    catch(reason: any): MaybePromise<undefined>;
}
declare class HostNode<T> extends ParentNode<T> {
    dirtyProps: boolean;
    dirtyChildren: boolean;
    dirtyRemoval: boolean;
    private iterating;
    private finished;
    readonly tag: string | symbol;
    readonly key: Key;
    readonly parent: ParentNode<T> | undefined;
    readonly renderer: Renderer<T>;
    value: T | undefined;
    private readonly intrinsic;
    private iterator;
    private childValues;
    constructor(parent: ParentNode<T> | undefined, renderer: Renderer<T>, tag: string | symbol, key: unknown, props: any);
    commit(requester?: ParentNode<T>): MaybePromise<undefined>;
    commitSelf(): void;
    unmount(dirty?: boolean): MaybePromise<undefined>;
    [Symbol.iterator](): Generator<any, void, unknown>;
}
export declare type HostContext = HostNode<any>;
declare class ComponentNode<T, TProps> extends ParentNode<T> {
    private iterating;
    private finished;
    private stepping;
    private available;
    readonly tag: Component<TProps>;
    readonly key: Key;
    protected props: TProps;
    readonly parent: ParentNode<T>;
    readonly renderer: Renderer<T>;
    readonly ctx: Context<TProps>;
    private iterator;
    private oldResult;
    private componentType;
    private inflightPending;
    private enqueuedPending;
    private inflightResult;
    private enqueuedResult;
    private onProps;
    private provisions;
    constructor(parent: ParentNode<T>, renderer: Renderer<T>, tag: Component, key: Key, props: TProps);
    refresh(): MaybePromise<undefined>;
    update(props: TProps): MaybePromise<undefined>;
    protected updateChildren(children: Children): MaybePromise<undefined>;
    private run;
    private step;
    private advance;
    commit(requester?: ParentNode<T>): undefined;
    unmount(dirty?: boolean): MaybePromise<undefined>;
    catch(reason: any): MaybePromise<undefined>;
    get(name: unknown): any;
    set(name: unknown, value: any): void;
    [Symbol.iterator](): Generator<TProps>;
    [Symbol.asyncIterator](): AsyncGenerator<TProps>;
}
export interface ProvisionMap {
}
export declare class Context<TProps = any> extends CrankEventTarget {
    constructor(host: ComponentNode<any, TProps>, parent?: Context<TProps>);
    get<T extends keyof ProvisionMap>(name: T): ProvisionMap[T];
    get(name: any): any;
    set<T extends keyof ProvisionMap>(name: T, value: ProvisionMap[T]): void;
    set(name: any, value: any): void;
    [Symbol.iterator](): Generator<TProps>;
    [Symbol.asyncIterator](): AsyncGenerator<TProps>;
    refresh(): MaybePromise<undefined>;
}
export declare const Default: unique symbol;
export declare type Default = typeof Default;
export declare const Text: unique symbol;
export declare type Text = typeof Text;
export declare const Scopes: unique symbol;
export interface Scoper {
    [Default]?(tag: string | symbol, props: any): unknown;
    [tag: string]: unknown;
}
export interface Environment<T> {
    [Default]?(tag: string | symbol): Intrinsic<T>;
    [Text]?(text: string): string;
    [Scopes]?: Scoper;
    [tag: string]: Intrinsic<T>;
}
export declare class Renderer<T> {
    private cache;
    private defaultIntrinsics;
    private env;
    private scoper;
    constructor(env?: Environment<T>);
    extend(env?: Environment<T>): void;
    render(children: Children, root?: object): MaybePromise<T>;
    intrinsic(tag: string | symbol): Intrinsic<T>;
    scope(tag: string | symbol, props: any): unknown;
    text(text: string): string;
}
