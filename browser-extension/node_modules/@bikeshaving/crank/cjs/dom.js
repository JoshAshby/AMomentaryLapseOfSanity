'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var index = require('./index-f14db5f0.js');

var _a;
var SVG_NAMESPACE = "http://www.w3.org/2000/svg";
// TODO: create an allowlist/blocklist of props
function updateProps(el, props, newProps, namespace) {
    for (var name_1 in index.__assign(index.__assign({}, props), newProps)) {
        var value = props[name_1];
        var newValue = newProps[name_1];
        switch (name_1) {
            case "children":
                break;
            case "class":
            case "className": {
                if (namespace === SVG_NAMESPACE) {
                    el.setAttribute("class", newValue);
                }
                else {
                    el.className = newValue;
                }
                break;
            }
            case "style": {
                var style = el.style;
                if (style != null) {
                    if (newValue == null) {
                        el.removeAttribute("style");
                    }
                    else if (typeof newValue === "string") {
                        style.cssText = newValue;
                    }
                    else {
                        for (var styleName in index.__assign(index.__assign({}, value), newValue)) {
                            var styleValue = value && value[styleName];
                            var newStyleValue = newValue && newValue[styleName];
                            if (newStyleValue == null) {
                                style.removeProperty(styleName);
                            }
                            else if (styleValue !== newStyleValue) {
                                style.setProperty(styleName, newStyleValue);
                            }
                        }
                    }
                }
                break;
            }
            default: {
                if (name_1 in el) {
                    el[name_1] = newValue;
                    break;
                }
                else if (newValue === true) {
                    el.setAttribute(name_1, "");
                }
                else if (newValue === false || newValue == null) {
                    el.removeAttribute(name_1);
                }
                else {
                    el.setAttribute(name_1, newValue);
                }
                break;
            }
        }
    }
}
function updateChildren(el, newChildren, dirtyStart) {
    if (newChildren.length === 0) {
        el.textContent = "";
        return;
    }
    var oldChild = newChildren[dirtyStart] === undefined
        ? el.firstChild
        : newChildren[dirtyStart];
    var ni = dirtyStart || 0;
    while (oldChild !== null && ni < newChildren.length) {
        var newChild = newChildren[ni];
        if (oldChild === newChild) {
            oldChild = oldChild.nextSibling;
            ni++;
        }
        else if (typeof newChild === "string") {
            if (oldChild.splitText !== undefined) {
                oldChild.nodeValue = newChild;
                oldChild = oldChild.nextSibling;
            }
            else {
                el.insertBefore(document.createTextNode(newChild), oldChild);
            }
            ni++;
        }
        else if (oldChild.splitText !== undefined) {
            var nextSibling = oldChild.nextSibling;
            el.removeChild(oldChild);
            oldChild = nextSibling;
        }
        else {
            el.insertBefore(newChild, oldChild);
            ni++;
            // TODO: this is an optimization for the js frameworks benchmark
            // swap rows, but we need to think a little more about other
            // pathological cases.
            if (oldChild !== newChildren[ni]) {
                var nextSibling = oldChild.nextSibling;
                el.removeChild(oldChild);
                oldChild = nextSibling;
            }
        }
    }
    while (oldChild !== null) {
        var nextSibling = oldChild.nextSibling;
        el.removeChild(oldChild);
        oldChild = nextSibling;
    }
    for (; ni < newChildren.length; ni++) {
        var newChild = newChildren[ni];
        el.appendChild(typeof newChild === "string"
            ? document.createTextNode(newChild)
            : newChild);
    }
}
function createDocumentFragmentFromHTML(html) {
    if (typeof document.createRange === "function") {
        return document.createRange().createContextualFragment(html);
    }
    else {
        var fragment = document.createDocumentFragment();
        var childNodes = new DOMParser().parseFromString(html, "text/html").body
            .childNodes;
        for (var i = 0; i < childNodes.length; i++) {
            fragment.appendChild(childNodes[i]);
        }
        return fragment;
    }
}
// TODO: Environment type should probably be Element | DocumentFragment
var env = (_a = {},
    _a[index.Default] = function (tag) {
        if (typeof tag !== "string") {
            throw new Error("Unknown tag: " + tag.toString());
        }
        var cachedEl;
        return function defaultDOM() {
            var ns, el, props, oldLength, _a, _b, nextProps, e_1_1;
            var e_1, _c;
            return index.__generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        ns = tag === "svg" ? SVG_NAMESPACE : this.scope;
                        if (cachedEl === undefined) {
                            if (ns == null) {
                                cachedEl = document.createElement(tag);
                            }
                            else {
                                cachedEl = document.createElementNS(ns, tag);
                            }
                        }
                        el = cachedEl.cloneNode();
                        props = {};
                        oldLength = 0;
                        _d.label = 1;
                    case 1:
                        _d.trys.push([1, , 10, 11]);
                        _d.label = 2;
                    case 2:
                        _d.trys.push([2, 7, 8, 9]);
                        _a = index.__values(this), _b = _a.next();
                        _d.label = 3;
                    case 3:
                        if (!!_b.done) return [3 /*break*/, 6];
                        nextProps = _b.value;
                        // We can’t use referential identity of props because we don’t have any
                        // restrictions like elements have to be immutable.
                        if (this.dirtyProps) {
                            updateProps(el, props, nextProps, ns);
                        }
                        if (this.dirtyChildren &&
                            nextProps.innerHTML === undefined &&
                            (oldLength > 0 || nextProps.children.length > 0)) {
                            updateChildren(el, nextProps.children, this.dirtyStart);
                        }
                        props = nextProps;
                        oldLength = nextProps.children.length;
                        return [4 /*yield*/, el];
                    case 4:
                        _d.sent();
                        _d.label = 5;
                    case 5:
                        _b = _a.next();
                        return [3 /*break*/, 3];
                    case 6: return [3 /*break*/, 9];
                    case 7:
                        e_1_1 = _d.sent();
                        e_1 = { error: e_1_1 };
                        return [3 /*break*/, 9];
                    case 8:
                        try {
                            if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                        }
                        finally { if (e_1) throw e_1.error; }
                        return [7 /*endfinally*/];
                    case 9: return [3 /*break*/, 11];
                    case 10:
                        if (this.dirtyRemoval && el.parentNode !== null) {
                            el.parentNode.removeChild(el);
                        }
                        return [7 /*endfinally*/];
                    case 11: return [2 /*return*/];
                }
            });
        };
    },
    _a[index.Raw] = function (_a) {
        var fragment, _b, _c, newValue, e_2_1;
        var e_2, _d;
        var value = _a.value;
        return index.__generator(this, function (_e) {
            switch (_e.label) {
                case 0:
                    _e.trys.push([0, 7, 8, 9]);
                    _b = index.__values(this), _c = _b.next();
                    _e.label = 1;
                case 1:
                    if (!!_c.done) return [3 /*break*/, 6];
                    newValue = _c.value.value;
                    if (!(typeof value === "string")) return [3 /*break*/, 3];
                    if (fragment === undefined || value !== newValue) {
                        fragment = createDocumentFragmentFromHTML(value);
                        value = newValue;
                    }
                    // TODO: figure out what the type of this Environment actually is
                    return [4 /*yield*/, fragment];
                case 2:
                    // TODO: figure out what the type of this Environment actually is
                    _e.sent();
                    return [3 /*break*/, 5];
                case 3:
                    fragment = undefined;
                    return [4 /*yield*/, value];
                case 4:
                    _e.sent();
                    _e.label = 5;
                case 5:
                    _c = _b.next();
                    return [3 /*break*/, 1];
                case 6: return [3 /*break*/, 9];
                case 7:
                    e_2_1 = _e.sent();
                    e_2 = { error: e_2_1 };
                    return [3 /*break*/, 9];
                case 8:
                    try {
                        if (_c && !_c.done && (_d = _b.return)) _d.call(_b);
                    }
                    finally { if (e_2) throw e_2.error; }
                    return [7 /*endfinally*/];
                case 9: return [2 /*return*/];
            }
        });
    },
    _a[index.Portal] = function (_a) {
        var _b, _c, _d, newRoot, children, e_3_1;
        var e_3, _e;
        var root = _a.root;
        return index.__generator(this, function (_f) {
            switch (_f.label) {
                case 0:
                    if (root == null) {
                        throw new TypeError("Portal element is missing root node");
                    }
                    _f.label = 1;
                case 1:
                    _f.trys.push([1, , 10, 11]);
                    _f.label = 2;
                case 2:
                    _f.trys.push([2, 7, 8, 9]);
                    _b = index.__values(this), _c = _b.next();
                    _f.label = 3;
                case 3:
                    if (!!_c.done) return [3 /*break*/, 6];
                    _d = _c.value, newRoot = _d.root, children = _d.children;
                    if (newRoot == null) {
                        throw new TypeError("Portal element is missing root node");
                    }
                    if (root !== newRoot) {
                        updateChildren(root, []);
                        root = newRoot;
                        updateChildren(root, children);
                    }
                    else if (this.dirtyChildren) {
                        updateChildren(root, children);
                    }
                    return [4 /*yield*/, root];
                case 4:
                    _f.sent();
                    _f.label = 5;
                case 5:
                    _c = _b.next();
                    return [3 /*break*/, 3];
                case 6: return [3 /*break*/, 9];
                case 7:
                    e_3_1 = _f.sent();
                    e_3 = { error: e_3_1 };
                    return [3 /*break*/, 9];
                case 8:
                    try {
                        if (_c && !_c.done && (_e = _b.return)) _e.call(_b);
                    }
                    finally { if (e_3) throw e_3.error; }
                    return [7 /*endfinally*/];
                case 9: return [3 /*break*/, 11];
                case 10:
                    updateChildren(root, []);
                    return [7 /*endfinally*/];
                case 11: return [2 /*return*/];
            }
        });
    },
    _a[index.Scopes] = {
        svg: SVG_NAMESPACE,
        foreignObject: undefined,
    },
    _a);
var DOMRenderer = /** @class */ (function (_super) {
    index.__extends(DOMRenderer, _super);
    function DOMRenderer() {
        return _super.call(this, env) || this;
    }
    return DOMRenderer;
}(index.Renderer));
var renderer = new DOMRenderer();

exports.DOMRenderer = DOMRenderer;
exports.env = env;
exports.renderer = renderer;
//# sourceMappingURL=dom.js.map
